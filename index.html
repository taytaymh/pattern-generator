<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Pixel Art Pattern Generator</title>
<style>
/* ‚Äî‚Äî‚Äî your existing styles unchanged ‚Äî‚Äî‚Äî */
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Arial',sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:20px;color:#333}
.container{max-width:1200px;margin:0 auto;background:rgba(255,255,255,.95);border-radius:20px;padding:30px;box-shadow:0 20px 40px rgba(0,0,0,.1);backdrop-filter:blur(10px)}
h1{text-align:center;color:#4a5568;margin-bottom:30px;font-size:2.5rem;background:linear-gradient(135deg,#667eea,#764ba2);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
.controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:20px;margin-bottom:30px}
.control-group{background:#f7fafc;padding:20px;border-radius:12px;border:2px solid #e2e8f0;transition:all .3s ease}
.control-group:hover{border-color:#667eea;transform:translateY(-2px);box-shadow:0 8px 25px rgba(102,126,234,.15)}
label{display:block;margin-bottom:8px;font-weight:600;color:#4a5568}
input[type="file"]{width:100%;padding:10px;border:2px dashed #cbd5e0;border-radius:8px;background:#fff;transition:all .3s ease}
input[type="file"]:hover{border-color:#667eea;background:#f0f4ff}
input[type="range"]{width:100%;margin:10px 0;-webkit-appearance:none;height:6px;border-radius:3px;background:#e2e8f0;outline:none}
input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:20px;height:20px;border-radius:50%;background:linear-gradient(135deg,#667eea,#764ba2);cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,.2)}
.range-display{display:flex;justify-content:space-between;font-size:.9rem;color:#718096}
.current-value{font-weight:bold;color:#667eea}
button{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-size:1rem;font-weight:600;transition:all .3s ease;box-shadow:0 4px 15px rgba(102,126,234,.3)}
button:hover{transform:translateY(-2px);box-shadow:0 8px 25px rgba(102,126,234,.4)}
button:disabled{opacity:.5;cursor:not-allowed;transform:none;box-shadow:none}
.preview-section{margin-top:30px}
.preview-container{display:flex;gap:30px;justify-content:center;flex-wrap:wrap}
.preview-box{background:#fff;border-radius:12px;padding:20px;box-shadow:0 8px 25px rgba(0,0,0,.1);max-width:400px}
.preview-box h3{margin-bottom:15px;color:#4a5568;text-align:center}
#originalPreview,#pixelPreview{max-width:100%;height:auto;border-radius:8px;box-shadow:0 4px 15px rgba(0,0,0,.1)}
.color-palette{margin-top:20px;text-align:center}
.color-swatch{display:inline-block;width:40px;height:40px;margin:5px;border-radius:8px;border:3px solid #e2e8f0;box-shadow:0 2px 4px rgba(0,0,0,.1);cursor:pointer;transition:all .3s ease;position:relative}
.color-swatch:hover{transform:scale(1.1);border-color:#667eea;box-shadow:0 4px 15px rgba(102,126,234,.3)}
.color-picker-overlay{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer}
.editable-colors{background:#f0f4ff;border:2px solid #667eea;border-radius:12px;padding:15px;margin-top:15px}
.editable-colors h4{margin-bottom:10px;color:#4a5568}
.download-section{text-align:center;margin-top:30px;padding-top:30px;border-top:2px solid #e2e8f0}
.info{background:#e6fffa;border-left:4px solid #38b2ac;padding:15px;margin:20px 0;border-radius:0 8px 8px 0}
@media (max-width:768px){.controls{grid-template-columns:1fr}.preview-container{flex-direction:column;align-items:center}h1{font-size:2rem}}
</style>
</head>
<body>
<div class="container">
  <h1>üß∂ Tapestry Pattern Generator üß∂</h1>
  

  <div class="controls">
    <div class="control-group">
      <label for="imageInput">Select Image:</label>
      <input type="file" id="imageInput" accept="image/*" />
      <div style="margin-top:8px;font-size:.8rem;color:#718096;">
        üìÅ Maximum file size: 10MB | Supported: JPG, PNG, GIF, WebP
      </div>
    </div>

    <div class="control-group">
      <label for="colorCount">Number of Colors:</label>
      <input type="range" id="colorCount" min="2" max="20" value="8" />
      <div class="range-display">
        <span>2</span>
        <span class="current-value" id="colorValue">8</span>
        <span>20</span>
      </div>
    </div>

    <div class="control-group">
      <label for="pixelWidth">Pattern Width (pixels):</label>
      <input type="range" id="pixelWidth" min="20" max="300" value="150" />
      <div class="range-display">
        <span>20</span>
        <span class="current-value" id="widthValue">150</span>
        <span>300</span>
      </div>
    </div>

    <!-- NEW: Brightness -->
    <div class="control-group">
      <label for="brightness">Brightness (‚àí100 to +100):</label>
      <input type="range" id="brightness" min="-100" max="100" value="0" />
      <div class="range-display">
        <span>‚àí100</span>
        <span class="current-value" id="brightnessValue">0</span>
        <span>+100</span>
      </div>
    </div>

    <!-- NEW: Contrast -->
    <div class="control-group">
      <label for="contrast">Contrast (‚àí100 to +100):</label>
      <input type="range" id="contrast" min="-100" max="100" value="0" />
      <div class="range-display">
        <span>‚àí100</span>
        <span class="current-value" id="contrastValue">0</span>
        <span>+100</span>
      </div>
    </div>
  </div>

  <div class="info">
    üí° <strong>Tips:</strong> <br>‚Ä¢ Choose fewer colors for a simpler pattern. <br>‚Ä¢ Smaller pixel widths work better for beginners. <br>‚Ä¢ Reset adjustments to return to original image settings.<br>‚Ä¢ Use brightness to lighten/darken, contrast to punch up edges.
  </div>

  <div class="preview-section">
    <div class="preview-container">
      <div class="preview-box">
        <h3>Original Image</h3>
        <img id="originalPreview" style="display:none;" />
      </div>
      <div class="preview-box">
        <h3>Pixel Art Preview</h3>
        <canvas id="pixelPreview" style="display:none;"></canvas>
        <div class="color-palette" id="colorPalette"></div>
      </div>
    </div>
  </div>

  <div class="download-section">
    <button id="downloadBtn" disabled>üåà Download Colored Pattern</button>
    <p style="margin-top:10px;color:#718096;font-size:.9rem;">
      Downloads a HTML file that opens in Excel & Google Sheets. <br><b>Please note:</b> You will need to adjust the height/width of the cells manually to make them square.
    </p>
  </div>
</div>

<script>
class PixelArtGenerator {
  constructor() {
    this.originalImage = null;
    this.pixelData = [];
    this.colorPalette = [];
    this.originalFileName = '';
    this.initializeEventListeners();
  }

  initializeEventListeners() {
    const $ = (id)=>document.getElementById(id);

    $('imageInput').addEventListener('change', this.handleImageUpload.bind(this));
    $('colorCount').addEventListener('input', ()=>{ $('colorValue').textContent = $('colorCount').value; this.generatePixelArt(); });
    $('pixelWidth').addEventListener('input', ()=>{ $('widthValue').textContent = $('pixelWidth').value; this.generatePixelArt(); });
    $('downloadBtn').addEventListener('click', this.downloadCSV.bind(this));

    // NEW: live updates for brightness/contrast
    $('brightness').addEventListener('input', ()=>{ $('brightnessValue').textContent = $('brightness').value; this.generatePixelArt(); });
    $('contrast').addEventListener('input', ()=>{ $('contrastValue').textContent = $('contrast').value; this.generatePixelArt(); });

    // Also regenerate on change end (mobile friendliness)
    ['colorCount','pixelWidth','brightness','contrast'].forEach(id=>{
      $(id).addEventListener('change', this.generatePixelArt.bind(this));
    });
  }

  handleImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    const maxSize = 10 * 1024 * 1024;
    if (file.size > maxSize) {
      alert('File size too large! Please choose an image smaller than 10MB.');
      event.target.value = '';
      return;
    }

    this.originalFileName = file.name.split('.')[0];

    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        this.originalImage = img;
        this.showOriginalPreview(img);
        this.generatePixelArt();
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }

  showOriginalPreview(img) {
    const preview = document.getElementById('originalPreview');
    preview.src = img.src;
    preview.style.display = 'block';
  }

  // ‚Äî‚Äî‚Äî core pipeline ‚Äî‚Äî‚Äî
  generatePixelArt() {
    if (!this.originalImage) return;

    const targetWidth  = parseInt(document.getElementById('pixelWidth').value);
    const colorCount   = parseInt(document.getElementById('colorCount').value);
    const brightness   = parseInt(document.getElementById('brightness').value); // -100..100
    const contrast     = parseInt(document.getElementById('contrast').value);   // -100..100

    // 1) Downscale to target size
    const aspectRatio = this.originalImage.height / this.originalImage.width;
    const targetHeight = Math.round(targetWidth * aspectRatio);

    const workCanvas = document.createElement('canvas');
    const ctx = workCanvas.getContext('2d');
    workCanvas.width = targetWidth;
    workCanvas.height = targetHeight;
    ctx.drawImage(this.originalImage, 0, 0, targetWidth, targetHeight);

    // 2) Get pixels and apply brightness/contrast
    const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);
    this.applyBrightnessContrast(imageData.data, brightness, contrast);

    // 3) Palette extraction (k-means) on adjusted pixels
    this.colorPalette = this.extractColorPalette(imageData.data, colorCount);

    // 4) Map pixels to nearest palette color
    const pixels = imageData.data;
    this.pixelData = [];
    for (let i = 0; i < pixels.length; i += 4) {
      const r = pixels[i], g = pixels[i+1], b = pixels[i+2];
      const closest = this.findClosestColor(r,g,b);
      this.pixelData.push(closest);
      pixels[i] = closest.r; pixels[i+1] = closest.g; pixels[i+2] = closest.b;
    }
    ctx.putImageData(imageData, 0, 0);

    // 5) Show
    this.showPixelPreview(workCanvas, targetWidth, targetHeight);
    this.showColorPalette();
    document.getElementById('downloadBtn').disabled = false;
  }

  // NEW: brightness/contrast processor
  applyBrightnessContrast(pixels, brightness, contrast) {
    // brightness: add offset
    const offset = 255 * (brightness / 100); // -255..+255
    // contrast formula (contrast in -100..100)
    const c = contrast;
    const factor = (259 * (c + 255)) / (255 * (259 - c)); // classic contrast curve

    for (let i = 0; i < pixels.length; i += 4) {
      // skip alpha (i+3)
      pixels[i]   = this.clamp(factor * (pixels[i]   - 128) + 128 + offset);
      pixels[i+1] = this.clamp(factor * (pixels[i+1] - 128) + 128 + offset);
      pixels[i+2] = this.clamp(factor * (pixels[i+2] - 128) + 128 + offset);
    }
  }

  clamp(v){ return Math.max(0, Math.min(255, Math.round(v))); }

  extractColorPalette(pixels, colorCount) {
    const colors = [];
    for (let i = 0; i < pixels.length; i += 4) {
      colors.push({ r: pixels[i], g: pixels[i+1], b: pixels[i+2] });
    }
    return this.kMeansClustering(colors, colorCount);
  }

  kMeansClustering(colors, k) {
    let centroids = [];
    for (let i = 0; i < k; i++) {
      const r = colors[Math.floor(Math.random() * colors.length)];
      centroids.push({ ...r });
    }
    for (let iter = 0; iter < 10; iter++) {
      const clusters = Array(k).fill(null).map(()=>[]);
      colors.forEach(col=>{
        let min = Infinity, idx = 0;
        centroids.forEach((c,i)=>{
          const d = this.colorDistance(col,c);
          if (d < min){ min = d; idx = i; }
        });
        clusters[idx].push(col);
      });
      centroids = clusters.map((cluster, i)=>{
        if (cluster.length === 0) return centroids[i] || centroids[0];
        const sum = cluster.reduce((s,c)=>({r:s.r+c.r,g:s.g+c.g,b:s.b+c.b}),{r:0,g:0,b:0});
        return { r:Math.round(sum.r/cluster.length), g:Math.round(sum.g/cluster.length), b:Math.round(sum.b/cluster.length) };
      });
    }
    return centroids;
  }

  colorDistance(c1,c2){
    return Math.hypot(c1.r-c2.r, c1.g-c2.g, c1.b-c2.b);
  }

  findClosestColor(r,g,b){
    let min = Infinity, best = this.colorPalette[0];
    for (const c of this.colorPalette){
      const d = this.colorDistance({r,g,b}, c);
      if (d < min){ min = d; best = c; }
    }
    return best;
  }

  showPixelPreview(canvas, w, h){
    const preview = document.getElementById('pixelPreview');
    const pctx = preview.getContext('2d');
    const scale = Math.min(400 / w, 400 / h);
    preview.width = w * scale;
    preview.height = h * scale;
    pctx.imageSmoothingEnabled = false;
    pctx.drawImage(canvas, 0, 0, w*scale, h*scale);
    preview.style.display = 'block';
  }

  showColorPalette(){
    const paletteDiv = document.getElementById('colorPalette');
    paletteDiv.innerHTML = '<div class="editable-colors"><h4>üé® Color Palette (click to edit):</h4></div>';
    const wrap = paletteDiv.querySelector('.editable-colors');
    this.colorPalette.forEach((color, index)=>{
      const holder = document.createElement('div');
      holder.style.display='inline-block';
      holder.style.position='relative';
      const swatch = document.createElement('div');
      swatch.className='color-swatch';
      swatch.style.backgroundColor = `rgb(${color.r},${color.g},${color.b})`;
      swatch.title = `Color ${index+1}: RGB(${color.r}, ${color.g}, ${color.b}) - Click to change`;
      const picker = document.createElement('input');
      picker.type='color';
      picker.className='color-picker-overlay';
      picker.value = this.rgbToHex(color.r, color.g, color.b);
      picker.addEventListener('change', (e)=>{
        const rgb = this.hexToRgb(e.target.value);
        this.colorPalette[index] = rgb;
        swatch.style.backgroundColor = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
        swatch.title = `Color ${index+1}: RGB(${rgb.r}, ${rgb.g}, ${rgb.b}) - Click to change`;
        this.regenerateWithNewColors();
      });
      holder.appendChild(swatch);
      holder.appendChild(picker);
      wrap.appendChild(holder);
    });
  }

  hexToRgb(hex){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return m ? { r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16) } : null;
  }

  regenerateWithNewColors(){
    if (!this.originalImage) return;

    const targetWidth  = parseInt(document.getElementById('pixelWidth').value);
    const brightness   = parseInt(document.getElementById('brightness').value);
    const contrast     = parseInt(document.getElementById('contrast').value);

    const aspectRatio = this.originalImage.height / this.originalImage.width;
    const targetHeight = Math.round(targetWidth * aspectRatio);

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = targetWidth;
    canvas.height = targetHeight;
    ctx.drawImage(this.originalImage, 0, 0, targetWidth, targetHeight);

    const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);
    // ensure palette edit reflects same pre-quantization adjustments
    this.applyBrightnessContrast(imageData.data, brightness, contrast);

    const px = imageData.data;
    this.pixelData = [];
    for (let i = 0; i < px.length; i += 4) {
      const closest = this.findClosestColor(px[i], px[i+1], px[i+2]);
      this.pixelData.push(closest);
      px[i]=closest.r; px[i+1]=closest.g; px[i+2]=closest.b;
    }
    ctx.putImageData(imageData, 0, 0);
    this.showPixelPreview(canvas, targetWidth, targetHeight);
  }

  downloadCSV(){
    if (this.pixelData.length === 0) return;
    const width = parseInt(document.getElementById('pixelWidth').value);
    const height = Math.ceil(this.pixelData.length / width);
    this.createColoredExcel(width, height);
  }

  createColoredExcel(width, height){
    let html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Crochet/Knitting Pattern</title>
<style>
table{border-collapse:collapse;table-layout:fixed;font-family:monospace}
td{border:1px solid #000;text-align:center;vertical-align:middle;font-size:14px;font-weight:bold;padding:0;margin:0;box-sizing:border-box;overflow:hidden;line-height:1}
.pattern-cell{width:30px!important;height:30px!important;min-width:30px!important;max-width:30px!important;min-height:30px!important;max-height:30px!important}
.legend-table td{width:auto!important;height:auto!important;min-width:auto!important;max-width:none!important;min-height:auto!important;max-height:none!important;padding:8px}
@media print{.pattern-cell{width:.4in!important;height:.4in!important}}
</style></head><body>
<h2>üß∂ Tapestry Pattern üß∂</h2>
<p><strong>Pattern Size:</strong> ${width} x ${height} | <strong>Colors:</strong> ${this.colorPalette.length}</p>
<p><em>üí° Tip: Match row height to column width for perfect squares.</em></p>
<h3>Color Legend:</h3>
<table class="legend-table"><tr><th>Symbol</th><th>Color</th><th>RGB</th><th>Hex</th></tr>`;
    this.colorPalette.forEach((c, i)=>{
      const sym = this.getColorSymbol(i);
      html += `<tr>
<td style="background-color:rgb(${c.r},${c.g},${c.b});color:${this.getContrastColor(c)};font-weight:bold;width:40px;height:30px;text-align:center">${sym}</td>
<td style="background-color:rgb(${c.r},${c.g},${c.b});width:60px;height:30px"></td>
<td>RGB(${c.r}, ${c.g}, ${c.b})</td>
<td>${this.rgbToHex(c.r,c.g,c.b)}</td>
</tr>`;
    });
    html += `</table><br><h3>Pattern Grid:</h3><table><colgroup>`;
    for (let x=0;x<width;x++) html += `<col style="width:30px">`;
    html += `</colgroup>`;

    for (let y=0;y<height;y++){
      html += `<tr style="height:30px">`;
      for (let x=0;x<width;x++){
        const i = y*width + x;
        if (i < this.pixelData.length){
          const p = this.pixelData[i];
          const idx = this.colorPalette.findIndex(c=>c.r===p.r && c.g===p.g && c.b===p.b);
          const sym = this.getColorSymbol(idx);
          const txt = this.getContrastColor(p);
          html += `<td class="pattern-cell" style="background-color:rgb(${p.r},${p.g},${p.b});color:${txt};text-align:center;vertical-align:middle;border:1px solid #000">${sym}</td>`;
        } else {
          html += `<td class="pattern-cell" style="border:1px solid #000"></td>`;
        }
      }
      html += `</tr>`;
    }
    html += `</table></body></html>`;
    const blob = new Blob([html], {type:'text/html'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${this.originalFileName || 'pixel-art'}-pattern.html`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  getColorSymbol(i){
    const symbols = ['‚óè','‚ñ≤','‚ñ†','‚ô¶','‚òÖ','‚ñº','‚óÜ','‚ô£','‚ô†','‚ô•','‚óá','‚óã','‚ñ≥','‚ñ°','‚òÜ','‚ñΩ','‚óà','‚ô™','‚Äª','‚¨ü'];
    return symbols[i % symbols.length];
  }
  getContrastColor(c){
    const L = (0.299*c.r + 0.587*c.g + 0.114*c.b)/255;
    return L > 0.5 ? '#000000' : '#FFFFFF';
  }
  rgbToHex(r,g,b){ return "#" + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1).toUpperCase(); }
}

document.addEventListener('DOMContentLoaded', ()=> new PixelArtGenerator());
</script>
</body>
</html>
